Ejercicios de programación IV: Gráficos y estadística
=====================================================

### [IMSER 2013]

- - -

Archivos incluidos:
-------------------

El [archivo](http://goo.gl/eFUKY) con los ejercicios del práctico debe bajarse y descomprimirse en disco duro, creando la carpeta **`rep-X`** (nota: no debe dentro de ningún disco, partición o carpeta protegida a la escritura, como puede ser un disco duro externo de backup). Usted deberá abrir el RStudio y seleccionar dicha carpeta como su directorio de trabajo con `setwd` o en RStudio la combinación **Ctrl + Shift + K**. En esta carpeta se encuentran algunos archivos que usted deberá modificar:

* **` xxxx.R `**

Adicionalmente los siguientes archivos son necesarios, pero **no deben ser modificados** para que el método de calificación automático funcione correctamente.

* ` evaluar.R `
* ` notas.csv `
* ` datos `
* ` INSTRUCCIONES.pdf `

Mecanismo de corrección:
------------------------

Nota: más recomendaciones **importantes** se hacen en el documento [Dinámica de los repartidos](http://goo.gl/P5Wnq).

Lo primero que debe hacer es cargar el archivo evaluar.R con la función `source` y la codificación de caracteres "UTF-8" (lo cual afecta a la función `evaluar` en particular), de la siguiente manera:

```{r eval=FALSE}
options(encoding = "utf-8")
source("evaluar.R")
```

Si usted ha ejecutado todos los pasos anteriores correctamente, la siguiente frase debería verse en la consola:

    Archivo de codigo fuente cargado correctamente

En caso de que ocurra un error o se vea otro mensaje en la consola, verifique que los archivos se descomprimieron correctamente y que usted está trabajando en la carpeta correspondiente con el comando `getwd()`.

Usted trabajará modificando los contenidos de dichos archivos con RStudio (u otro programa de su preferencia) según las consignas que se describen a continuación. Luego de terminar cada ejercicio y **guardando el archivo** correspondiente en el disco duro, usted podrá verificar rápidamente si su respuesta es correcta ejecutando el comando:

```{r eval=FALSE}
evaluar()
```

y además podrá en todo momento verificar su puntaje con la función `verNotas()`. Tenga siempre en cuenta que, a **menos que sea indicado** por la letra del ejercicio, las soluciones deben ser genéricas y por lo tanto deben servir aún si se modifican los datos originales (i.e.: no use valores fijos si no comandos). Usualmente se utilizan valores generados de forma aleatoria para las correcciones automáticas. Los objetos que son evaluados en la corrección automática estarán indicados con un asterísco en las instrucciones de cada script. Nótese además que en los archivos **se indica claramente en dónde se inicia y dónde finaliza su código** y que debe respetar esta organización para que la corrección de los ejercicios funcione bien.

### Al finalizar

Una vez terminados y guardados los archivos de los ejercicios del repartido, usted deberá ejecutar `evaluar()` y seleccionar la última opción ("Todos") y luego subir el archivo ”datos” (sin extensión), incluido en la carpeta ”rep-1”, a la [sección de entregas](http://eva.universidad.edu.uy/mod/assign/view.php?id=103966) de la portada del curso en la plataforma EVA. Este archivo se podrá reemplazar con uno más nuevo, en caso de que desee corregir algún error; en caso de querer que el archivo sea corregido antes de la fecha de entrega, puede cambiarle el nombre a "datos-finalizado", pero en ese caso la nota no se cambiará de ahí en adelante.


### Código de Honor

Si bien animamos a que trabaje en equipos y que haya un intercambio fluido en los foros del curso, es fundamental que las respuestas a los cuestionarios y ejercicios de programación sean fruto del trabajo individual. En particular, consideramos necesario que no utilice el código creado por sus compañeros, si no que debe programar sus propias instrucciones, ya que de lo contrario supone un sabotaje a su propio proceso de aprendizaje. Esto implica también evitar, en la medida de lo posible, exponer el código propio a sus colegas. Como profesores estamos comprometidos a dar nuestro mayor esfuerzo para dar las herramientas y explicaciones adecuadas a fin de que pueda encontrar su propio camino para resolver los ejercicios.

En casos de planteos de dudas a través del foro, en los que considere que es imposible expresar un problema sin exponer su própio código, entonces es aceptable hacerlo. De todas formas en estos casos es preferible que envíe su código por correo electrónico directamente a un profesor, explicando la problemática.

- - -


1. Distribución de funciones
----------------------------

El data.frame "Pacientes" presenta dos columnas, con datos obtenidos de 100 pacientes consultados: por un lado (col. 1) la el número de consultas médicas por año y por otro (col. 2) la frecuencia obtenida para ese valor (i.e.: la cantidad de veces que ese número fue respondido). Por lo tanto, podemos observar por ejemplo que XX personas consultadas concurren una vez por año médico. Si vemos el histograma de la segunda variable (`barplot(pacientes[, 2])`) para conocer la distribución del evento podemos observar que la cantidad de pacientes que visitan al medico anualmente puede ser descrito por una FDP del tipo Poisson.

Recuerde que la distribución de probabilidad de Poisson presenta como única variable a $\lambda$ que es la media y la varianza de la FDP. Para mayores consultas busque en la ayuda `?dpois`.

Se desea conocer cual es el máximo valor de $\lambda$ para el rango de valores dado. Este valor obtenido del parámetro será el que maximice la densidad de datos de los pacientes. (???)

Para esto primero debe realizar una función genérica que permita calcular la densidad de probabilidad para cada dato.
Esta función se llama `dpois.pacientes`. Note que se transforman los datos con el logaritmo natural debido a que es mas sencillo calcular el máximo de un número.

Luego se debe definir el argumento lambda de la función `dpois.pacientes`, el cual es una secuencia de valores de dicho parámetro. Esto servirá para conocer cuál es el máximo valor esperado de pacientes por año que concurre al médico. Para esto último recomendamos utilizar y consultar en la ayuda la función `sapply`.

previamente el estudiante deberá importar la tabla pacientes, la cual será un data.frame con el mismo nombre.


densidad: densidad de probabilidad para cada dato $x_i$ que se distribuye con una función de probabilidad tipo Poisson.
transformado: logaritmo natural de los valores de densidad obtenidos.
promedio: promedio de todos los valores transformados. Observe que esta función debe ser negativa para que los valores sean positivos.
`max.lambda`: valor de lambda para el cual es máxima la función `dpois.pacientes`. Los valores de lambda debe estar comprendidos entre 1 y 4.

```{r}
npac <- 5000
true.lambda <- 4
respuestas <- rpois(npac, true.lambda)

pacientes <- data.frame(A = as.numeric(names(table(respuestas))), 
                        B = as.numeric(table(respuestas)))
barplot(pacientes[,2])

lambda.min <- 1
lambda.max <- 8

pacientes <- read.table("pacientes.csv", header=TRUE, sep=",")

dpois.pacientes <- function(lambda) {
  
  densidad <- dpois(pacientes[, 1], lambda)
  transformado <- log(densidad)
  promedio <- - mean(transformado)
  
}

dpois.pacientes <- function(lambda) {
  
  densidad <- dpois(pacientes[, 1], lambda)
  dens.obs <- pacientes[,2] / sum(pacientes[,2])
  transformado <- log(densidad)
  trans.obs <- log(dens.obs)
  promedio <- - mean(transformado - trans.obs)
  
}

max.lambda <- max(sapply(lambda.min:lambda.max, dpois.pacientes))
```

2. blablablablabla
------------------

#### a.
Importar la tabla de la hoja de cálculo a R; el objeto resultante debe ser una data.frame llamada `magic` y sus columnas deben llamarse `body.size`, `sex` y `height` (i.e.: los valores que R asigna por defecto).

Debe guardarse en la carpeta del parcial el archivo de texto (.txt o .csv) utilizado para la importación.

```{r}
magic <- read.csv2("datos.csv")
```

#### b.
Generar un vector aleatorio llamado `age`, compuesto por números enteros positivos entre 18 y 35 aprox. (este rango puede tener cierta flexibilidad). Nota: debe ser generado con una función creadora de valores aleatorios, y se deben permitir ocurrencias repetidas del mismo valor.

```{r}
age <- rpois(40, nrow(magic))
```

#### c.
Agregar la variable `age` al data.frame `magic`.

```{r}
magic$age <- age
```

#### d.
La variable `sex` del data.frame presenta los valores 1 y 2. Transformar esta variable en factor. Luego modificar los nombres de los niveles del mismo a `"mujer"` y `"hombre"` (correspondientes a los valores originales 1 y 2 respectivamente).

```{r}
magic$sex <- as.factor(magic$sex)
levels(magic$sex) <- c("mujer", "hombre")
```

#### e.
Crear la variable factorial `agef` basada en `age` de forma tal que cuente con 3 niveles (dividiendo el rango en 3 franjas etarias de igual amplitud). Agregar dicha variable a la data.frame `magic`.

```{r}
magic$agef <- cut(magic$age, 3)
```

#### f.
Nombrar a cada uno de los niveles de la variable `agef` (dentro de `magic`) como `"novatos"`, `"intermedios"`, `"expertos"`, en ese orden.

```{r}
levels(magic$agef) <- c("novatos", "intermedios", "expertos")
```

#### g.
Cambiar los nombres de las columnas del data.frame a `"peso"`, `"sexo"`, `"altura"`, `"edad"` y `"edadf"`.

```{r}
names(magic) <- c("peso", "sexo", "altura", "edad", "edadf")
```

#### h.
Graficar: peso en función de sexo. El gráfico debe ser un diagrama de cajas y tener las etiquetas "Sexo", "Peso (Kg)" en los ejes correspondientes, así como el título: "Peso en función del sexo".

```{r}
plot(peso ~ sexo, magic, main = "Peso en función del sexo", xlab = "Sexo", ylab = "Peso (Kg)")
```

#### i.
Realizar un anova con la variable de respuesta `peso` y la variable explicativa `sexo`; guardar el resultado en el objeto `peso.sexo`.

```{r}
peso.sexo <- aov(peso ~ sexo, magic)
```

#### j.
Crear los objetos `peso.hombre` y `peso.mujer` con los valores esperados de peso para los sexos respectivos, según los resultados del modelo `peso.sexo` creado en el punto anterior (considere la interpretación de los coeficientes del anova dada en la lección correspondiente).

```{r}
peso.mujer <- coef(peso.sexo)[1]
peso.hombre <- sum(coef(peso.sexo))
# o 
peso.mujer <- mean(magic$peso[magic$sexo == "mujer"])
peso.hombre <- mean(magic$peso[magic$sexo == "hombre"])
# o
ag <- aggregate(peso ~ sexo, data = magic, FUN = mean)
peso.mujer <- ag[1, 2]
peso.hombre <- ag[2, 2]

# Otros usos cool de aggregate:
aggregate(peso ~ sexo + edadf, data=magic, FUN=mean)
aggregate(cbind(peso, altura) ~ sexo, data=magic, FUN=mean)
```

#### k.
Graficar: $altura ^ 2$ (altura al cuadrado) en función del peso.

```{r}
plot(altura ^ 2 ~ peso, magic)
```

#### l.
Realizar una regresión lineal entre estas dos variables ($altura ^ 2$ ~ peso) sin intercepto. El modelo obtenido debe guardarse en el objeto `altura.peso`.

```{r}
altura.peso <- lm(altura ^ 2 ~ peso - 1, magic)
```

#### m.
Realizar una regresión lineal entre estas dos variables ($altura ^ 2$ ~ peso) sin intercepto, pero esta vez excluyendo a los outliers de peso (es decir, aquellos tales que peso > 120 Kg). Guardar el modelo en el objeto `altura.peso2`.

```{r}
altura.peso2 <- lm(altura ^ 2 ~ peso - 1, magic, subset = peso <= 120)
```

#### n.
Utilizando los coeficientes obtenidos en este segundo modelo, determine la altura esperada para la secuencia de pesos:  

$$
  a ^ 2 = c \cdot p
  a = \sqrt{c \cdot p}
$$

```{r}
p <- seq(40, 120, by = 0.5)
ae <- sqrt(coef(altura.peso) * p)
```
    
Los valores de altura esperados se deben guardar en un objeto llamado `ae`.

(Nótese que el modelo establece la relación del peso con la $altura ^ 2$, pero no con la altura per se). 

#### o.
Guardar en el objeto `r2` el valor del $R^2$ (*no ajustado*) del modelo (es decir, el coeficiente de determinación o "proporción de varianza explicada"). Cuidado: no confundir con el $R^2$ ajustado.

```{r}
s <- summary(altura.peso)
r2 <- s$r.squared
```

#### p.  
Agregar al último gráfico creado anteriormente las líneas correspondientes a ambas regresiones lineales, utilizando diferentes trazos y/o colores para diferenciarlas.

```{r}
abline(altura.peso)
abline(altura.peso2, col=2)
```

#### q.
Agregar una línea vertical indicando el valor 120 en el eje del peso; utilice un estilo de línea diferente a los anteriores (con color y/o trazo diferente).

```{r}
abline(v = 120, lty = 2)
```

#### r.
Superponer al mismo gráfico los puntos de los outliers en peso, utilizando un símbolo diferente (y opcionalmente, un color distinto), de forma tal que se puedan diferenciar a simple vista.

```{r}
points(altura ^ 2 ~ peso, magic, subset = peso > 120, pch = 19)
```

#### s.
Agregar una última variable, llamada `IMC`, a la data.frame `magic`: el [índice IMC](http://es.wikipedia.org/wiki/%C3%8Dndice_de_masa_corporal) correspondiente a cada participante, calculado como:

$$
  IMC = \frac{Peso (Kg)}{Altura ^ 2 (m)}
$$

```{r}
magic$IMC <- with(magic, peso / (altura ** 2))
```

#### t.
Exportar la data.frame `magic` a un archivo de texto plano (.txt o .csv), conteniendo todas las columnas agregadas y los encabezados, pero excluyendo los nombres de fila.

```{r}
write.csv2(magic, "magic.csv", row.names = FALSE)
```
